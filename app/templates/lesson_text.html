{# app/templates/lesson_text.html V1.14 - Integrated Recording & Improved Quiz Logic Interaction #}
{% extends "base.html" %} {# 继承基础模板 #}

{# 设置页面标题 #}
{% block title %}Lesson {{ lesson.lesson_number }} - {{ lesson.title_en or 'Lesson Text' }}{% endblock %}

{% block content %}
{# --- 1. 增强型标题区域 --- #}
<div class="p-4 p-md-5 mb-4 rounded-3 bg-light shadow-sm border-start border-primary border-5">
    <div class="container-fluid py-3">
        <h1 class="display-5 fw-bold">Lesson {{ lesson.lesson_number }}: {{ lesson.title_en or 'Unknown Title' }}</h1>
        {% if lesson.title_cn %}
            <p class="fs-4 text-muted">{{ lesson.title_cn }}</p>
        {% endif %}
    </div>
</div>

{# --- 2. 英文课文、音频和录音主区域 --- #}
<div class="p-4 border rounded-3 bg-white shadow mb-4">
    <h3 class="mb-4 pb-2 border-bottom"><i class="bi bi-file-earmark-text-fill"></i> 英文课文与跟读练习</h3>

    {# --- 音频和录音控件行 --- #}
    <div class="row g-3 mb-4 align-items-center">
        {# 预生成音频播放器 #}
        <div class="col-md-6">
            {% if audio_url %}
                <div id="lesson-audio-player"> {# 可以保留外层 div 的 ID，如果其他地方用到的话 #}
                    <label class="form-label small fw-bold">课程音频:</label>
                    {# --- 给 audio 标签添加 ID --- #}
                    <audio id="pre-generated-audio-player" controls preload="metadata" class="w-100" title="播放预生成的课程音频">
                        <source src="{{ audio_url }}" type="audio/wav"> {# 确认 audio_url 被正确传递 #}
                        你的浏览器不支持播放 WAV 音频。
                    </audio>
                    {# --- 结束添加 ID --- #}
                </div>
            {% else %}
                <div class="text-muted small"><i class="bi bi-exclamation-circle"></i> 暂无预生成音频。</div>
            {% endif %}
        </div>
        {# 用户录音控件 #}
        <div class="col-md-6">
             <div class="p-3 border rounded-2 bg-light-subtle h-100">
                <label class="form-label small fw-bold">跟读录音:</label>
                <div class="d-flex align-items-center mb-2">
                    <button id="record-button" class="btn btn-danger btn-sm me-2"><i class="bi bi-mic-fill"></i> 开始录音</button>
                    <span id="recording-status" class="text-muted small flex-grow-1"></span>
                </div>
                <div id="user-recording-playback" style="min-height: 40px;"></div>
            </div>
        </div>
    </div>

    {# --- 英文课文内容 --- #}
    {# 应用拟物化纸张样式 #}
    <div class="lesson-text english-text preserve-newlines border-top pt-3" id="english-text-content">
        {% if lesson.text_en %}
             {{ lesson.text_en }}
        {% else %}
            <p class="text-muted"><em>English text not available.</em></p>
        {% endif %}
    </div>
</div>
{# --- 英文区域结束 --- #}


{# --- 3. 操作按钮区域 --- #}
<div class="mb-4 pt-3 text-center border-top">
    <a href="{{ url_for('view_lessons') }}" class="btn btn-secondary me-2"><i class="bi bi-arrow-left-circle"></i> 返回课程列表</a>
    <button type="button" id="start-lesson-quiz-btn" class="btn btn-success" data-lesson-number="{{ lesson.lesson_number }}"><i class="bi bi-question-circle-fill"></i> 测试本课词汇</button>
</div>

{# --- 4. 隐藏的 Quiz 和 Results 区域 (供 quiz_logic.js 使用) --- #}
<div class="dynamic-content-area mt-4">
    <div id="quiz-area" class="hidden p-3 border rounded bg-light shadow-sm">
         <h2 class="text-center mb-4">Lesson {{ lesson.lesson_number }} 词汇测试进行中...</h2>
         <div id="questions-container"></div>
         {# Note: submit-quiz-btn listener is attached by quiz_logic.js #}
         <div class="text-center"><button type="button" id="submit-quiz-btn" class="btn btn-primary hidden mt-3">提交答案</button></div>
    </div>
    <div id="results-area" class="hidden mt-4 p-3 border rounded bg-light shadow-sm">
         <h2>测试结果</h2>
         <p>你的得分: <span id="score" class="fw-bold"></span> / <span id="total-questions"></span></p>
         <h3 id="incorrect-title">错题回顾:</h3>
         <ul id="incorrect-list" class="list-group list-group-flush mb-3"></ul>
         <button type="button" id="restart-quiz-btn" class="btn btn-info hidden">重新测试本课 (Quiz Again)</button>
    </div>
    <div id="loading-indicator" class="hidden mt-4 text-center">
        <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
        <p class="text-muted mt-2">请稍候...</p>
    </div>
     <div id="error-message" class="alert alert-danger hidden mt-4" role="alert"></div>
</div>
{# --- 隐藏区域结束 --- #}

{# --- 5. 中文参考译文区域 (默认显示) --- #}
{% if lesson.text_cn %}
<hr class="my-4">
<div class="translation-section">
    <div id="collapseTranslation">
      <div class="card card-body bg-light border-secondary">
          <h5 class="card-title text-muted">参考译文 (Translation)</h5>
          <div class="lesson-text chinese-text preserve-newlines small">
                {% set cn_paragraphs = lesson.text_cn.split('\n') %}
                {% for para in cn_paragraphs %}{% if para.strip() %}<p class="mb-2">{{ para }}</p>{% endif %}{% endfor %}
          </div>
      </div>
    </div>
</div>
{% endif %}
{# --- 中文区域结束 --- #}

{% endblock %}

{# --- 特定页面 CSS (修正背景平铺问题) --- #}
{% block styles_extra %}
<style>
    /* --- 整体页面背景优化 (示例) --- */
    /* body { background: linear-gradient(to bottom right, #e0f7fa, #b2ebf2); background-attachment: fixed; } */

    /* --- 内容区域容器的微调 (示例) --- */
     .rounded-3.bg-white.shadow,
     .rounded-3.bg-light.shadow-sm,
     .translation-section .card {
        box-shadow: 0 0.75rem 1.5rem rgba(0, 0, 0, 0.1) !important;
        border-color: rgba(0, 0, 0, 0.08) !important;
     }

    /* === 主题 3: 拟物化“纸张”效果 (修正背景) === */
    .lesson-text.english-text {
        background-color: #fefefe; /* 纸张的底色 */
        background-image: url('{{ url_for("static", filename="images/lesson.png") }}'); /* 纸张纹理 */

        /* --- 修改开始 --- */
        background-repeat: no-repeat;  /* 禁止背景图片重复平铺 */
        background-size: cover;      /* 让背景图片缩放以完全覆盖元素区域 */
                                     /* 保持图片的宽高比，可能会裁剪掉部分图片 */
        background-position: center center; /* 图片居中显示，裁剪时优先保留中间部分 */
        /* --- 修改结束 --- */

        color: #222; /* 更深的文字颜色 */
        font-family: 'Playfair Display', serif; /* 更具艺术感的字体 (需引入) */
        font-size: 1.15rem;
        line-height: 1.9;
        letter-spacing: 0.03em;

        padding: 2.5rem; /* 纸张边缘的留白 */

        border-radius: 8px; /* 纸张的圆角 */
        box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15), 0 0 10px rgba(0, 0, 0, 0.05) inset; /* 内外阴影 */

        white-space: pre-line; /* 保留换行符 */
        position: relative;
        overflow: hidden; /* 隐藏超出边界的背景图部分 */
    }
    /* === 主题 3 结束 === */


    /* --- 中文参考译文样式 --- */
    .chinese-text p { margin-bottom: 0.5em; line-height: 1.6; }

    /* --- 其他通用样式 --- */
    .translation-section .card-title { font-size: 1rem; }
    .border-5 { border-width: 5px !important; }
    .preserve-newlines { white-space: pre-line; }
    .dynamic-content-area { min-height: 200px; }
    .hidden { display: none !important; }
    .recording-indicator::before { /* ... */ }
    @keyframes blink { /* ... */ }

    /* 提醒：字体引入 */
</style>
{% endblock %}


{% block scripts_extra %}
<script>
    // --- Specific Page Script Starts ---
    console.log('lesson_text.html: Script block reached');

    // --- 全局变量，用于跟踪状态和互斥 ---
    let isCurrentlyRecording = false; // 跟踪录音状态
    let isCurrentlySpeaking = false; // 跟踪 TTS 朗读状态 (如果使用 TTS)
    let currentAudioElement = null; // 指向当前正在播放的 <audio> 元素 (预生成或录音)
    let mediaRecorderInstance = null; // 持有 MediaRecorder 实例
    let mediaStreamInstance = null;  // 持有麦克风流
    let recordedAudioChunks = []; // 持有录音数据块

    // --- DOM Element References (声明在顶层，赋值在 DOMContentLoaded) ---
    let recordButton = null;
    let recordingStatus = null;
    let audioPlaybackContainer = null;
    let preGeneratedAudio = null;
    let speakButton = null;
    let voiceSelect = null;
    let textToSpeakElement = null;
    let startLessonQuizBtn = null;
    let restartQuizBtn = null; // 注意：这个元素在 results-area 内部，初始可能不存在
    // quizArea, resultsArea 等由 quiz_logic.js 获取和管理

    // --- DOMContentLoaded Listener: 获取元素并调用初始化函数 ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log('lesson_text.html: DOM fully loaded');

        // === 1. 获取所有页面元素并赋值给顶层变量 ===
        recordButton = document.getElementById('record-button');
        recordingStatus = document.getElementById('recording-status');
        audioPlaybackContainer = document.getElementById('user-recording-playback');
        preGeneratedAudio = document.getElementById('pre-generated-audio-player');
        speakButton = document.getElementById('speak-button'); // 可能为 null
        voiceSelect = document.getElementById('voice-select'); // 可能为 null
        textToSpeakElement = document.getElementById('english-text-content'); // 应该存在
        startLessonQuizBtn = document.getElementById('start-lesson-quiz-btn'); // 应该存在
        // restartQuizBtn 在 resultsArea 内部，初始获取可能为 null
        restartQuizBtn = document.getElementById('restart-quiz-btn');

        console.log("DOM elements potentially assigned. Checking availability...");

        // === 新增：检查并加载之前的录音 ===
        const previousRecordingUrl = "{{ user_recording_audio_url or '' }}"; // 从后端获取 URL
        if (previousRecordingUrl && audioPlaybackContainer) {
            console.log("Previous recording found, creating player:", previousRecordingUrl);
            try {
                const audioElement = document.createElement('audio');
                audioElement.controls = true;
                audioElement.src = previousRecordingUrl; // 使用后端提供的 URL
                audioElement.title = "你之前的录音";
                audioElement.classList.add("w-100", "mt-2");
                // 添加播放事件监听以实现互斥
                audioElement.addEventListener('play', () => { handleUserAudioPlay(audioElement); });
                audioElement.addEventListener('pause', handleAudioStop);
                audioElement.addEventListener('ended', handleAudioStop);

                audioPlaybackContainer.innerHTML = ''; // 清空容器
                audioPlaybackContainer.appendChild(audioElement); // 添加播放器
                console.log("Previous recording player added.");
            } catch(e) {
                console.error("Error creating player for previous recording:", e);
            }
        } else if (audioPlaybackContainer) {
            // 如果没有找到之前的录音，确保播放区域是空的或显示提示
            // audioPlaybackContainer.innerHTML = '<p class="text-muted small m-0">暂无之前的录音。</p>';
             console.log("No previous recording URL found.");
        }
        // === 结束加载之前的录音 ===

        // === 2. 在获取元素之后，再调用初始化函数，并进行检查 ===

        // 初始化录音逻辑
        try {
            if (recordButton && recordingStatus && audioPlaybackContainer) {
                initializeRecordingLogic(); // 调用顶层函数
                console.log("Recording setup initiated.");
            } else {
                console.warn("Recording elements incomplete after DOM loaded. Recording disabled.");
                if (!recordButton) console.log("-> recordButton (#record-button) not found.");
                if (!recordingStatus) console.log("-> recordingStatus (#recording-status) not found.");
                if (!audioPlaybackContainer) console.log("-> audioPlaybackContainer (#user-recording-playback) not found.");
                if (recordButton) recordButton.disabled = true;
            }
        } catch (recordError) {
            console.error("Recording Init Error caught in DOMContentLoaded:", recordError);
            if(recordButton) recordButton.disabled = true;
        }

        // 初始化语音合成逻辑
        try {
            if (speakButton && textToSpeakElement && voiceSelect) {
                initializeSpeechSynthesis(); // 调用顶层函数
                console.log("Speech setup initiated.");
            } else {
                 console.log("Speech synthesis elements not found or incomplete after DOM loaded, TTS disabled.");
                 if (!speakButton) console.log("-> speakButton (#speak-button) not found.");
                 if (!textToSpeakElement) console.log("-> textToSpeakElement (#english-text-content) not found.");
                 if (!voiceSelect) console.log("-> voiceSelect (#voice-select) not found.");
                 if (speakButton) speakButton.disabled = true;
                 if (voiceSelect) voiceSelect.disabled = true;
            }
        } catch (speechError) {
            console.error("Speech Init Error caught in DOMContentLoaded:", speechError);
            if(speakButton) speakButton.disabled = true;
            if(voiceSelect) voiceSelect.disabled = true;
        }

        // 初始化课程测验逻辑
        try {
            if (startLessonQuizBtn) {
                initializeLessonQuizLogic(); // 调用顶层函数
                console.log("Lesson quiz logic setup initiated.");
            } else {
                 console.warn("Start Lesson Quiz button (#start-lesson-quiz-btn) not found after DOM loaded. Quiz init skipped.");
            }
        } catch (quizError) {
            console.error("Quiz Init Error caught in DOMContentLoaded:", quizError);
             if(startLessonQuizBtn) startLessonQuizBtn.disabled = true;
        }

        // 为预生成的音频添加播放事件监听
        if (preGeneratedAudio) {
            preGeneratedAudio.addEventListener('play', handlePreGeneratedAudioPlay);
            preGeneratedAudio.addEventListener('pause', handleAudioStop);
            preGeneratedAudio.addEventListener('ended', handleAudioStop);
             console.log("Event listeners attached to pre-generated audio player.");
        } else {
             console.log("Pre-generated audio player element not found after DOM loaded.");
        }

        console.log("lesson_text.html: DOMContentLoaded handler finished setup.");

    }); // --- End of DOMContentLoaded listener ---


    // ================================================
    // === UI 更新函数 (顶层) ===
    // ================================================
    /**
     * Updates the recording button and status text based on the current state.
     * Relies on global 'recordButton' and 'recordingStatus' elements being fetched in DOMContentLoaded.
     * @param {string} state - 'idle', 'recording', 'stopping', 'unavailable'
     */
    function updateRecordingUI(state) {
        if (!recordButton || !recordingStatus) {
             console.warn("updateRecordingUI called but recordButton or recordingStatus element not ready.");
             return;
        }
        isCurrentlyRecording = state === 'recording';
        // console.log("Updating recording UI to state:", state); // Optional debug log

        switch (state) {
            case 'idle':
                recordButton.innerHTML = '<i class="bi bi-mic-fill"></i> 开始录音';
                recordButton.classList.remove('btn-warning', 'btn-secondary');
                recordButton.classList.add('btn-danger');
                recordingStatus.textContent = '';
                recordButton.disabled = false;
                break;
            case 'recording':
                recordButton.innerHTML = '<i class="bi bi-stop-fill"></i> 停止录音';
                recordButton.classList.remove('btn-danger', 'btn-warning');
                recordButton.classList.add('btn-secondary');
                recordingStatus.textContent = '正在录音...';
                recordButton.disabled = false;
                break;
            case 'stopping':
                recordButton.innerHTML = '<i class="bi bi-hourglass-split"></i> 处理中...';
                recordButton.classList.remove('btn-danger', 'btn-secondary');
                recordButton.classList.add('btn-warning');
                recordButton.disabled = true;
                recordingStatus.textContent = '处理录音中...';
                break;
            case 'unavailable':
                recordButton.innerHTML = '<i class="bi bi-mic-mute-fill"></i> 无法录音';
                recordButton.classList.remove('btn-danger', 'btn-warning');
                recordButton.classList.add('btn-secondary');
                recordButton.disabled = true;
                // recordingStatus text is set by the error handler
                break;
            default:
                 console.warn("Unknown recording UI state:", state);
                 if (recordButton && recordingStatus) {
                     updateRecordingUI('idle');
                 }
        }
    } // --- End updateRecordingUI ---


    // ======================================
    // === Speech Synthesis Initialization (顶层) ===
    // ======================================
    function initializeSpeechSynthesis() {
        if (!speakButton || !textToSpeakElement || !voiceSelect) { console.warn("Cannot init TTS: elements missing."); return; }
        if ('speechSynthesis' in window) {
            const synth = window.speechSynthesis;
            let voices = [];

            function populateVoiceList() {
                 try {
                     voices = synth.getVoices();
                     if (!voiceSelect) { console.warn("Voice select element disappeared before populating."); return; }
                     voiceSelect.innerHTML = ''; // Clear existing options
                     let defaultSelected = false;
                     voices.forEach((voice) => {
                         if (voice.lang.startsWith('en')) { // Filter for English
                             const option = document.createElement('option');
                             option.textContent = `${voice.name} (${voice.lang})`;
                             option.value = voice.name; // Use name as value
                             option.setAttribute('data-lang', voice.lang);
                             option.setAttribute('data-name', voice.name);
                             if (!defaultSelected && (voice.lang === 'en-US' || voice.lang === 'en-GB') && voice.default) {
                                 option.selected = true;
                                 defaultSelected = true;
                             }
                             voiceSelect.appendChild(option);
                         }
                     });
                     if (!defaultSelected && voiceSelect.options.length > 0) {
                          const firstUS = Array.from(voiceSelect.options).find(opt => opt.dataset.lang === 'en-US');
                          if (firstUS) firstUS.selected = true;
                          else voiceSelect.options[0].selected = true;
                     }
                 } catch (e) { console.error("Error populating voice list:", e); }
            }

            populateVoiceList();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = populateVoiceList;
            } else {
                 setTimeout(populateVoiceList, 200);
            }

            speakButton.addEventListener('click', () => {
                stopPlaybackAndRecording(); // Stop other media first
                if (synth.speaking) {
                    console.log("Stopping previous speech.");
                    synth.cancel(); // Triggers onend/onerror
                } else {
                    const textToSpeak = textToSpeakElement.textContent || textToSpeakElement.innerText;
                    if (!textToSpeak) { console.warn("No text content found to speak."); return; }
                    const utterThis = new SpeechSynthesisUtterance(textToSpeak);
                    const selectedOption = voiceSelect.selectedOptions[0];
                    const selectedVoiceName = selectedOption ? selectedOption.value : null;
                    const currentVoices = synth.getVoices(); // Refetch voices
                    const selectedVoice = selectedVoiceName ? currentVoices.find(voice => voice.name === selectedVoiceName) : null;
                    if (selectedVoice) { utterThis.voice = selectedVoice; utterThis.lang = selectedVoice.lang; } else { console.warn("Selected voice not found, using browser default."); }
                    utterThis.pitch = 1; utterThis.rate = 1;
                    utterThis.onstart = () => { console.log("Speech started."); isCurrentlySpeaking = true; speakButton.innerHTML = '<i class="bi bi-stop-fill"></i> 停止'; };
                    utterThis.onend = () => { console.log("Speech finished or cancelled."); isCurrentlySpeaking = false; speakButton.innerHTML = '<i class="bi bi-play-fill"></i> 朗读'; };
                    utterThis.onerror = (event) => { console.error('Speech error:', event); isCurrentlySpeaking = false; speakButton.innerHTML = '<i class="bi bi-play-fill"></i> 朗读'; };
                    synth.speak(utterThis);
                }
            });
            console.log("Speech synthesis initialized.");
        } else {
             console.warn("Speech Synthesis not supported by this browser.");
             if(speakButton) speakButton.disabled = true; speakButton.title = '浏览器不支持';
             if(voiceSelect) voiceSelect.disabled = true;
        }
    } // --- End of initializeSpeechSynthesis ---


    // ======================================
    // === Recording Logic Initialization (顶层) ===
    // ======================================
    function initializeRecordingLogic() {
        console.log("lesson_text.html: Initializing Recording Logic...");
        if (!recordButton || !recordingStatus || !audioPlaybackContainer) { console.warn("Recording elements missing (init stage)."); if(recordButton) recordButton.disabled = true; return; }
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia || !window.MediaRecorder) { recordingStatus.textContent = "浏览器不支持录音"; recordButton.disabled = true; return; }

        recordButton.addEventListener('click', async () => {
            if (!isCurrentlyRecording) { // === Start Recording ===
                console.log("Record button clicked: Start recording...");
                stopPlaybackAndRecording(); updateRecordingUI('stopping');
                try {
                    mediaStreamInstance = await navigator.mediaDevices.getUserMedia({ audio: true }); console.log("Mic access granted.");
                    const options = { mimeType: 'audio/webm' }; if (!MediaRecorder.isTypeSupported(options.mimeType)) {options.mimeType='audio/ogg; codecs=opus';} if (!MediaRecorder.isTypeSupported(options.mimeType)) {options.mimeType='';} const recOpts=options.mimeType?{mimeType:options.mimeType}:undefined; console.log("Using options:", recOpts||"Default");
                    mediaRecorderInstance = new MediaRecorder(mediaStreamInstance, recOpts); recordedAudioChunks = [];
                    mediaRecorderInstance.ondataavailable = event => { if (event.data.size > 0) recordedAudioChunks.push(event.data); };
                    // --- onstop Handler ---
                    mediaRecorderInstance.onstop = async () => {
                        console.log("Recording stopped. Chunks:", recordedAudioChunks.length);
                        const stream = mediaStreamInstance; if (stream) stream.getTracks().forEach(t => t.stop()); mediaStreamInstance = null; console.log("Mic stream stopped.");
                        updateRecordingUI('stopping'); // Keep showing processing during this handler

                        if (recordedAudioChunks.length === 0) { console.warn("No data recorded."); recordingStatus.textContent = "录音数据为空。"; updateRecordingUI('idle'); return; }
                        let audioBlob = null, successLocal = false, savedToServer = false;
                        try {
                            console.log("Creating Blob..."); const blobOpts = mediaRecorderInstance.mimeType ? {type: mediaRecorderInstance.mimeType}:{}; audioBlob = new Blob(recordedAudioChunks, blobOpts); console.log("Blob created:", audioBlob.size, audioBlob.type); if (audioBlob.size === 0) throw new Error("Blob size 0.");
                            console.log("Creating Object URL..."); const audioUrl = URL.createObjectURL(audioBlob); console.log("Obj URL created.");
                            if (!audioPlaybackContainer) throw new Error("Playback container missing!"); console.log("Creating audio element...");
                            const audioElement = document.createElement('audio'); audioElement.controls = true; audioElement.src = audioUrl; audioElement.title="你的录音回放"; audioElement.classList.add("w-100","mt-2");
                            audioElement.addEventListener('play', () => { handleUserAudioPlay(audioElement); }); audioElement.addEventListener('pause', handleAudioStop); audioElement.addEventListener('ended', handleAudioStop);
                            console.log("Clearing playback container..."); audioPlaybackContainer.innerHTML = ''; console.log("Appending audio element..."); audioPlaybackContainer.appendChild(audioElement); console.log("Audio element appended."); successLocal = true;
                            // --- Upload Logic ---
                            const lessonNumber = startLessonQuizBtn?.dataset.lessonNumber || recordButton?.dataset.lessonNumber || "{{ lesson.lesson_number }}";
                            if (lessonNumber && audioBlob) {
                                console.log(`Uploading for lesson ${lessonNumber}...`); recordingStatus.textContent = "正在上传录音...";
                                const formData = new FormData(); let filename = `lesson_${lessonNumber}_rec.webm`; const mime=audioBlob.type.split(';')[0]; if(mime==='audio/ogg')filename=`lesson_${lessonNumber}_rec.ogg`; else if(mime==='audio/wav')filename=`lesson_${lessonNumber}_rec.wav`; formData.append('audio_data', audioBlob, filename);
                                const csrf = document.querySelector('meta[name="csrf-token"]')?.content; const headers = {'Accept':'application/json'}; if(csrf)headers['X-CSRFToken']=csrf; else console.warn("CSRF token missing for upload.");
                                try {
                                    const resp = await fetch(`/api/lesson/${lessonNumber}/upload_recording`, { method: 'POST', headers: headers, body: formData }); console.log("Upload status:", resp.status);
                                    if (!resp.ok) { let eMsg=`Upload failed (${resp.status})`; try{const d=await resp.json(); eMsg=d.error||eMsg;}catch(e){} throw new Error(eMsg); }
                                    const res = await resp.json(); if (res.success) { console.log("Upload OK:", res.message); recordingStatus.textContent = "录音已上传"; savedToServer = true; } else { throw new Error(res.error || "Upload failed (backend)"); }
                                } catch (upErr) { console.error("Upload error:", upErr); recordingStatus.textContent = `上传失败: ${upErr.message}`; }
                            } else { console.warn("Cannot upload: no lesson# or blob."); recordingStatus.textContent = "未上传:缺少信息"; }
                        } catch (procErr) { console.error("Local processing error:", procErr); recordingStatus.textContent = `处理失败: ${procErr.message}`; successLocal = false; }
                        finally { recordedAudioChunks = []; updateRecordingUI('idle'); console.log("Finally: UI idle, chunks cleared."); } // Always reset UI button state
                    }; // --- End onstop ---
                    mediaRecorderInstance.onerror = event => { console.error("Recorder error:", event.error); recordingStatus.textContent=`录音错误: ${event.error.name}`; updateRecordingUI('unavailable'); if(mediaStreamInstance)mediaStreamInstance.getTracks().forEach(t=>t.stop());mediaStreamInstance=null; setTimeout(()=>updateRecordingUI('idle'),3000); };
                    mediaRecorderInstance.start(); console.log("Recording started successfully."); updateRecordingUI('recording'); // Update UI
                } catch (err) { console.error('Mic/start failed:', err); recordingStatus.textContent = `无法访问麦克风: ${err.name}`; updateRecordingUI('unavailable'); if(mediaStreamInstance){mediaStreamInstance.getTracks().forEach(t=>t.stop());mediaStreamInstance=null;} setTimeout(() => updateRecordingUI('idle'), 3000); }
            } else { // === Stop Recording ===
                console.log("Stop Recording button clicked."); stopRecording();
            }
        });
        updateRecordingUI('idle'); // Set initial state
        console.log("Recording logic initialized and listener attached.");
    } // --- End of initializeRecordingLogic ---


    // ============================================
    // === Lesson Quiz Logic Initialization (顶层) ===
    // ============================================
    function initializeLessonQuizLogic() {
         console.log("lesson_text.html: Running initializeLessonQuizLogic...");
         // --- Check dependencies (window.quizLogic) ---
         if (typeof window.quizLogic === 'undefined' || !window.quizLogic.resetQuizUI || !window.quizLogic.showLoading || !window.quizLogic.showError || !window.quizLogic.displayQuestions) {
            console.error("CRITICAL - window.quizLogic or required functions not found!");
            alert("加载测验组件失败!"); if(startLessonQuizBtn) startLessonQuizBtn.disabled = true; return;
         }
         console.log("window.quizLogic confirmed.");

         // --- startLessonQuizLocal function ---
         async function startLessonQuizLocal(lessonNumber) {
             if (!lessonNumber) { console.error("No lesson number."); window.quizLogic.showError('无法获取课程编号。'); return; }
             console.log(`[1] Starting quiz L${lessonNumber}...`);
             stopPlaybackAndRecording(); // Stop media before starting quiz
             window.quizLogic.resetQuizUI(); window.quizLogic.showLoading(true); if (startLessonQuizBtn) startLessonQuizBtn.disabled = true;
             const numQ = 999; const qType = 'cn_to_en';
             // Ensure global context exists before setting properties
             if (typeof window.quizContext !== 'object' || window.quizContext === null) window.quizContext = { lesson_ids: [], quiz_type: "", question_ids: [] };
             window.quizContext.lesson_ids = [parseInt(lessonNumber)]; window.quizContext.quiz_type = qType; window.quizContext.question_ids = [];
             console.log("[2] Global quizContext set:", JSON.stringify(window.quizContext));
             try {
                 const url = `/api/quiz?lessons=${lessonNumber}&count=${numQ}&type=${qType}`; console.log("[3] Fetching:", url);
                 const resp = await fetch(url); console.log("[4] Status:", resp.status, "OK:", resp.ok);
                 if (!resp.ok) { let eMsg=`Load failed (${resp.status})`; try{const t=await resp.text(); if(resp.headers.get("content-type")?.includes("json"))eMsg=JSON.parse(t).error||eMsg; else eMsg+=`: ${t.slice(0,100)}`;}catch(e){} throw new Error(eMsg); }
                 console.log("[5b] Parsing JSON..."); const data = await resp.json(); console.log(`[6] Fetched data:`, data);
                 if (!data || !Array.isArray(data) || data.length === 0) { console.error("[7] Validation Failed!"); window.quizLogic.showError(`未能加载L${lessonNumber}词汇题`); if (startLessonQuizBtn) startLessonQuizBtn.disabled = false; window.quizLogic.resetQuizStateVariables(); return; }
                 window.currentQuizData = data; console.log("[8] Global currentQuizData SET");
                 window.quizContext.question_ids = data.map(q => q.id); console.log("[9] Context Q_IDs UPDATED");
                 console.log("[10] Calling displayQuestions..."); window.quizLogic.displayQuestions(data);
             } catch (error) { console.error('[11] Error:', error); window.quizLogic.showError(`开始测试失败: ${error.message}`); if (startLessonQuizBtn) startLessonQuizBtn.disabled = false; window.quizLogic.resetQuizStateVariables(); }
             finally { console.log("[12] finally."); window.quizLogic.showLoading(false); }
         } // --- End startLessonQuizLocal ---

         // --- Function to restart quiz ---
         function restartLessonQuizLocal() {
             console.log("Restarting quiz...");
             window.quizLogic.resetQuizUI(); // Use global reset
             // Re-fetch the restart button potentially, as it might have been re-rendered or was initially null
             const currentRestartBtn = document.getElementById('restart-quiz-btn');
             if (startLessonQuizBtn) { startLessonQuizBtn.disabled = false; }
             // Scroll to quiz options or start button after reset
             const quizOptionsSection = document.getElementById('quiz-options-section'); // Assuming this ID exists if coming from index
             const targetScrollElement = quizOptionsSection || startLessonQuizBtn;
             if(targetScrollElement) targetScrollElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
         }

         // --- Attach Listeners ---
         if (startLessonQuizBtn) { startLessonQuizBtn.addEventListener('click', () => { const lNum = startLessonQuizBtn.dataset.lessonNumber; startLessonQuizLocal(lNum); }); console.log("Listener attached to #start-lesson-quiz-btn."); }
         // Use event delegation for the restart button as it's inside the results area which might be rebuilt
         const resultsAreaForDelegation = document.getElementById('results-area'); // Get results area reference
         if(resultsAreaForDelegation){
             resultsAreaForDelegation.addEventListener('click', (event) => {
                  if (event.target && event.target.id === 'restart-quiz-btn') {
                       restartLessonQuizLocal();
                  }
             });
             console.log("Event listener attached to resultsArea for #restart-quiz-btn delegation.");
         } else {
              console.warn("#results-area not found for restart button delegation.");
         }
         // if (restartQuizBtn) { restartQuizBtn.addEventListener('click', restartLessonQuizLocal); console.log("Direct listener attached to #restart-quiz-btn."); } // Direct attachment might fail if hidden initially
         // else { console.warn("#restart-quiz-btn not found for direct listener attachment."); }
         console.log("lesson_text.html: Submit listener handled by quiz_logic.js.");
    } // --- End of initializeLessonQuizLogic ---


    // ================================================
    // === Helper Functions for Media Control (Top Level) ===
    // ================================================
    /** Stops ALL media playback, recording, and speech synthesis. */
    function stopPlaybackAndRecording() {
         console.log("Helper: stopPlaybackAndRecording called.");
         let stoppedSomething = false;
         // Stop any currently playing audio element
         if (currentAudioElement && typeof currentAudioElement.pause === 'function' && !currentAudioElement.paused) { console.log("Stopping current global audio element:", currentAudioElement.src.substring(0,50)+"..."); currentAudioElement.pause(); stoppedSomething = true; currentAudioElement = null; }
         else { /* Check specific elements just in case */ if (preGeneratedAudio && !preGeneratedAudio.paused) { preGeneratedAudio.pause(); stoppedSomething = true;} const userAudio = audioPlaybackContainer?.querySelector('audio'); if(userAudio && !userAudio.paused) { userAudio.pause(); stoppedSomething = true;} }
         // Stop Speech Synthesis
         if (window.speechSynthesis && window.speechSynthesis.speaking) { console.log("Stopping speech synthesis."); window.speechSynthesis.cancel(); isCurrentlySpeaking = false; if(speakButton) speakButton.innerHTML = '<i class="bi bi-play-fill"></i> 朗读'; stoppedSomething = true; }
         // Stop Recording
         if (isCurrentlyRecording) { console.log("Stopping ongoing recording via helper..."); stopRecording(); stoppedSomething = true; } // Call helper
         // if (stoppedSomething) console.log("Helper: stopPlaybackAndRecording finished stopping media."); else console.log("Helper: stopPlaybackAndRecording called, but nothing needed stopping.");
     }

    /** Stops all OTHER media playback/recording/speaking except the element passed as current. */
    function stopOtherMedia(currentMediaElement = null) {
        console.log("Helper: stopOtherMedia called, current element:", currentMediaElement ? currentMediaElement.tagName : 'null');
         // Stop pre-generated audio
         if (preGeneratedAudio && currentMediaElement !== preGeneratedAudio && !preGeneratedAudio.paused) { console.log("Pausing pre-generated audio."); preGeneratedAudio.pause(); if(currentAudioElement === preGeneratedAudio) currentAudioElement = null; }
         // Stop user recording playback
         const userAudio = audioPlaybackContainer ? audioPlaybackContainer.querySelector('audio') : null;
         if(userAudio && currentMediaElement !== userAudio && !userAudio.paused) { console.log("Pausing user recording playback."); userAudio.pause(); if(currentAudioElement === userAudio) currentAudioElement = null; }
         // Stop TTS
         if (window.speechSynthesis && window.speechSynthesis.speaking) { console.log("Stopping speech synthesis."); window.speechSynthesis.cancel(); isCurrentlySpeaking = false; if(speakButton) speakButton.innerHTML = '<i class="bi bi-play-fill"></i> 朗读'; }
         // Stop Recording
         if (isCurrentlyRecording) { console.log("Stopping ongoing recording."); stopRecording(); } // Call helper
    }

     /** Auxiliary function to specifically stop the recorder and update UI. */
     function stopRecording() {
          console.log("stopRecording helper called...");
          if (mediaRecorderInstance && mediaRecorderInstance.state === 'recording') {
              updateRecordingUI('stopping'); // Call top-level UI update
              mediaRecorderInstance.stop(); // Trigger the onstop event
              console.log("mediaRecorder.stop() called.");
          } else {
              console.warn("stopRecording helper called but recorder not active or instance missing.");
              updateRecordingUI('idle'); // Reset UI if stuck
              if (mediaStreamInstance) { mediaStreamInstance.getTracks().forEach(track => track.stop()); mediaStreamInstance = null; }
          }
     }

    // --- Event Handlers for Playback (now top-level) ---
    /** Handles 'play' event for the pre-generated audio element. */
    function handlePreGeneratedAudioPlay() {
         console.log("Pre-generated audio playback started.");
         currentAudioElement = preGeneratedAudio; // Mark as current
         stopOtherMedia(preGeneratedAudio); // Stop others
    }
    /** Handles 'play' event for the dynamically created user audio element. */
    function handleUserAudioPlay(audioElement) {
         console.log("User recording playback started.");
         currentAudioElement = audioElement; // Mark as current
         stopOtherMedia(audioElement); // Stop others
    }
    /** Handles 'pause' and 'ended' events for any audio element. */
    function handleAudioStop(event) {
         if (currentAudioElement === event.target) {
              console.log("Audio stopped/ended:", event.target.src.substring(0,50) + "..."); // Log source start
              currentAudioElement = null; // Clear mark
         }
    }

</script>
{% endblock %}